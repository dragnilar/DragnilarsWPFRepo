<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CrossJoinExplanation" xml:space="preserve">
    <value>- A Cross Join returns the rows in table A multiplied by the number of rows in table B. In other words, it shows all possible combinations. 
The end result is also called a "Cartesian Product".  This type of join will take a VERY long time to complete on big tables.

Note: IF you use a Where clause in a Cross Join, the Cross Join instead behaves exactly like a regular "Full Inner" Join!</value>
    <comment>Explanation of Cross Join</comment>
  </data>
  <data name="CrossJoinQuery" xml:space="preserve">
    <value>select AttributeWeaponType, AttributeName, WeaponName, WeaponType
From WeaponAttributes
	CROSS Join Weapons
Order By AttributeWeaponType</value>
    <comment>Query Used for cross join</comment>
  </data>
  <data name="FullInnerJoinExplanation" xml:space="preserve">
    <value>- A "Full Inner Join" returns records that match in both tables. So for this example, you are seeing records that match in WeaponAttributes and Weapons.
● The Squirt gun has a matching ID with attribute name cheap, but its weapon type is null and the attribute weapon type are null
● The Wooden Mallet has a matching ID with the attribute name offensive, but its weapon type is null and the attribute weapon type are null
● The Stringy Spatula has no match on WeaponId in the two tables, so you don't get anything for it.

Notes: In Microsoft SQL Server, a "Full Inner Join" is used when you just use "Join". So you actually do not need to type of "Full Inner"</value>
    <comment>Explanation of full inner join</comment>
  </data>
  <data name="FullInnerJoinQuery" xml:space="preserve">
    <value>select AttributeWeaponType, AttributeName, WeaponName, WeaponType
From WeaponAttributes
	 Join Weapons 
	on WeaponAttributes.WeaponId = Weapons.WeaponId
Order By AttributeWeaponType</value>
    <comment>Query used for full inner join</comment>
  </data>
  <data name="FullOuterJoinExplanation" xml:space="preserve">
    <value>- A "Full Outer Join" returns records in both tatbles that match on both sides where available. However, if there is no match then anything missing is null!
Thus a Full Outer Join can return more rows than a regular Inner Join.

● The spatula has no matching weapon attribute or name due to a lack of common ID, so you get two nulls in the left table.
● The squirt gun and mallet have no matching attribute weapon type or weapon type, so you get nulls on left and right since the two columns are null.
● The kitchen utensil/annoying attribute weapon types and names do not match any weapon Id's so you get nulls for the right table.
● Note that since there are no matches for KitchenUtensil/Annoying and StringySpatula/KitchenUtensil, you get 2 results for those two.

Note: In Microsoft SQL Server, the "Outer" part is optional. 

So you only need to type in "Full Join" in order to get a join where it returns rows with no matches on each side.

Note : Some databases do not support Outer Joins.

For example,
Sqlite does not support it. So you may notice the query being used on the right is completely different if you are using this application with a Sqlite databases.
 
</value>
    <comment>Explanation of Full Outer Join</comment>
  </data>
  <data name="FullOuterJoinQuery" xml:space="preserve">
    <value>select AttributeWeaponType, AttributeName, WeaponName, WeaponType
From WeaponAttributes
	Full Join Weapons 
	on WeaponAttributes.WeaponId = Weapons.WeaponId
Order By AttributeWeaponType</value>
    <comment>Query used for full outer join</comment>
  </data>
  <data name="FullOuterJoinQuerySqlite" xml:space="preserve">
    <value>SELECT AttributeWeaponType, AttributeName, WeaponName, WeaponType
FROM   WeaponAttributes 
       LEFT JOIN Weapons 
          ON WeaponAttributes.WeaponId = Weapons.WeaponId
UNION ALL
SELECT WeaponAttributes.AttributeWeaponType, WeaponAttributes.AttributeName, WeaponName, WeaponType
FROM  Weapons
       LEFT JOIN WeaponAttributes
          ON WeaponAttributes.WeaponId = Weapons.WeaponId
WHERE  WeaponAttributes.WeaponId IS NULL
order by AttributeWeaponType</value>
    <comment>Full Outer Join Work Around Query For Sqllite</comment>
  </data>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="JoinyJoinsDatabaseFill" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\JoinyJoinsDatabaseFill.sql;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;Windows-1252</value>
  </data>
  <data name="LeftJoinExplanation" xml:space="preserve">
    <value>- A Left Join returns all records from table A. If there are any matches in table B, they display. Otherwise you will get nulls.

● The null attribute weapon type with attribute name cheap has a matching weapon named squirt gun. The weapon type is null.
● The same is the case with offensive / wooden mallet.
● Annoying Kitchen utensil has no matches in the right table based off of weapon Id.</value>
    <comment>Explanation of Left Join</comment>
  </data>
  <data name="LeftJoinQuery" xml:space="preserve">
    <value>select AttributeWeaponType, AttributeName, WeaponName, WeaponType
From WeaponAttributes
	Left Join Weapons
	on WeaponAttributes.WeaponId = Weapons.WeaponId
Order By AttributeWeaponType</value>
    <comment>Query used for left join</comment>
  </data>
  <data name="RightJoinExplanation" xml:space="preserve">
    <value>- A Right Join returns all records from table B. If there are any matches in table A, they display. Otherwise you will get nulls.

● The squirt gun has a match on the left for the weapon attribute named cheap. Since there are no weapon types, they are null.
● The same is the case for the offensive/wooden mallet.
● Nothing in WeaponAttributes matches the Stringy Spatula, so you get nulls on the left

Note: Some databases do not support Full Outer Join. 

For example,
Sqlite does not support it. So you may notice the query being used on the right is completely different if you are using this application with a Sqlite databases.

Note 2: A right join is functionally the same as a left join, the only key difference is that the table order is reversed. So you can still do a right join using left join... just flip the tables!</value>
    <comment>Explanation of Right Join</comment>
  </data>
  <data name="RightJoinQuery" xml:space="preserve">
    <value>select AttributeWeaponType, AttributeName, WeaponName, WeaponType
From WeaponAttributes
	Right Join Weapons
	on WeaponAttributes.WeaponId = Weapons.WeaponId
Order By AttributeWeaponType</value>
    <comment>Query used for right join</comment>
  </data>
  <data name="RightJoinQuerySqlite" xml:space="preserve">
    <value>select AttributeWeaponType, AttributeName, WeaponName, WeaponType
From Weapons
	Left Join WeaponAttributes
	on Weapons.WeaponId = WeaponAttributes.WeaponId
Order By AttributeWeaponType</value>
    <comment>Right Join Work Around Query For SqlLite</comment>
  </data>
</root>